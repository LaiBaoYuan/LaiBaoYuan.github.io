import{_ as s,c as a,o,a as e}from"./app.fb84bbb4.js";const u=JSON.parse('{"title":"Sass 导入指令","description":"","frontmatter":{"title":"Sass 导入指令"},"headers":[],"relativePath":"notes/frontend/Sass/Sass导入指令.md","lastUpdated":1677921063000}'),p={name:"notes/frontend/Sass/Sass导入指令.md"},l=e(`<div class="tip custom-block"><p class="custom-block-title">前言</p><p>在 CSS 中我们可以通过 @import 来导入一个样式文件，Sass 扩展了 CSS 的 @import 规则，使得可以导入 CSS 后缀的样式文件和 Scss 后缀的样式文件，并且提供了对 mixin 、函数和变量的访问。</p></div><div class="warning custom-block"><p class="custom-block-title">提醒</p><p>与 CSS 的 @import 不同的是， CSS 使用 @import 导入文件是在页面渲染的时候发起多个 http 请求来获取文件内容，而 Sass 的导入 @import 是在编译时获取文件内容导入的。</p></div><h2 id="import" tabindex="-1">@import <a class="header-anchor" href="#import" aria-hidden="true">#</a></h2><p>Sass 的导入和 CSS 中的导入语法类似，只不过在 Sass 中<strong>可以导入用逗号分隔的多个文件</strong></p><div class="language-scss"><button title="Copy Code" class="copy"></button><span class="lang">scss</span><pre class="shiki dracula"><code><span class="line"><span style="color:#FF79C6;">@import</span><span style="color:#F8F8F2;"> </span><span style="color:#E9F284;">&#39;</span><span style="color:#F1FA8C;">a.scss</span><span style="color:#E9F284;">&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#E9F284;">&#39;</span><span style="color:#F1FA8C;">b.scss</span><span style="color:#E9F284;">&#39;</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"></span></code></pre></div><p>上面的代码意思是导入 a.scss 和 b.scss 文件，那么导入后 a 和 b 中的任何mixin 、函数和变量都是可以使用的。 我们知道在 CSS 中也有 @import 语句，在以下几种情况 Sass 会认为 @import 是 CSS 语句：</p><ul><li>使用 url()</li><li>文件的扩展名是 .css</li><li>@import 包含 media queries</li><li>文件名以 http:// 开头</li></ul><h2 id="使用-use-替代-import" tabindex="-1">使用 @use 替代 @import <a class="header-anchor" href="#使用-use-替代-import" aria-hidden="true">#</a></h2><p>Sass 官方团队不鼓励使用 <code>@import</code> 导入，并且在未来几年将逐步淘汰它，并最终将 <code>@import</code> 从 Sass 中完全删除。所以使用 <code>@use</code> 是官方团队更推荐的方式，下面我们开始讲解使用 <code>@use</code> 导入。</p><div class="language-scss"><button title="Copy Code" class="copy"></button><span class="lang">scss</span><pre class="shiki dracula"><code><span class="line"><span style="color:#FF79C6;">@use</span><span style="color:#F8F8F2;"> </span><span style="color:#E9F284;">&#39;</span><span style="color:#F1FA8C;">my/a.scss</span><span style="color:#E9F284;">&#39;</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"><span style="color:#FF79C6;">@use</span><span style="color:#F8F8F2;"> </span><span style="color:#E9F284;">&#39;</span><span style="color:#F1FA8C;">my/b</span><span style="color:#E9F284;">&#39;</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"></span></code></pre></div><p>从上面的代码中可以看到其使用方式与 <code>@import</code> 是相同的，那么为什么还要替换掉 <code>@import</code> 呢？ 主要是以下几个原因你需要了解下：</p><ul><li><code>@import</code> 会使得所有变量、mixin 和函数都可以全局访问，这使开发者很难去维护这些定义的东西。</li><li>因为所有的都是全局的，那么 Sass 必须为所有的成员添加前缀，以避免命名冲突。</li><li><code>@extend</code> 也是全局的，这样将很难预测哪些样式将被扩展。</li><li>每次使用 <code>@import</code> 时，每个样式表都会被执行，这会增加编译时间</li><li>无法定义下游样式表无法访问的私有成员。</li></ul>`,12),t=[l];function n(c,i,r,d,F,m){return o(),a("div",null,t)}const _=s(p,[["render",n]]);export{u as __pageData,_ as default};
